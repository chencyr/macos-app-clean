#!/usr/bin/env node
/**
 * macos-app-residue-tool.js
 *
 * 功能：
 * 1) 掃描 macOS 常見 App 安裝/殘留路徑，彙整成 groups
 * 2) 可用 --delete=<AppName> 對指定 App 名稱做殘留清理
 *
 * 用法：
 *   # 只掃描列出
 *   node macos-app-residue-tool.js
 *   node macos-app-residue-tool.js --minHits=2
 *   node macos-app-residue-tool.js --system
 *   node macos-app-residue-tool.js --filter=chrome
 *
 *   # 指定 App 清理（預設 dry-run）
 *   node macos-app-residue-tool.js --delete=chrome
 *
 *   # 真的執行：移到垃圾桶（預設）
 *   node macos-app-residue-tool.js --delete=chrome --force
 *
 *   # 真的執行：永久刪除（危險）
 *   node macos-app-residue-tool.js --delete=chrome --force --rm
 *
 *   # 匯出 JSON
 *   node macos-app-residue-tool.js --json > residues.json
 */

const fs = require("fs");
const path = require("path");
const os = require("os");

const argv = process.argv.slice(2);
const hasFlag = (f) => argv.includes(f);
const getArg = (key, def = null) => {
  const p = argv.find((a) => a.startsWith(`--${key}=`));
  if (!p) return def;
  return p.slice(key.length + 3);
};

const HOME = os.homedir();
const TRASH = path.join(HOME, ".Trash");

const includeSystem = hasFlag("--system");
const asJson = hasFlag("--json");
const filter = (getArg("filter", "") || "").toLowerCase();
const minHits = Number(getArg("minHits", "1")) || 1;

const deleteQuery = (getArg("delete", "") || "").trim().toLowerCase();
const force = hasFlag("--force");
const permanentRm = hasFlag("--rm"); // 若不加 --rm，預設移到垃圾桶（較安全）

const scanRoots = [
  "/Applications",
  path.join(HOME, "Applications"),

  path.join(HOME, "Library", "Application Support"),
  path.join(HOME, "Library", "Preferences"),
  path.join(HOME, "Library", "Caches"),
  path.join(HOME, "Library", "Logs"),
  path.join(HOME, "Library", "Saved Application State"),
  path.join(HOME, "Library", "Containers"),
  path.join(HOME, "Library", "Group Containers"),
];

if (includeSystem) {
  scanRoots.push(
    "/Library/Application Support",
    "/Library/Preferences",
    "/Library/Caches",
    "/Library/Logs",
    "/Library/LaunchAgents",
    "/Library/LaunchDaemons"
  );
}

const MAX_DEPTH = 2;
const NOISE_NAMES = new Set(["com.apple", "Apple", ".DS_Store", "CrashReporter", "DiagnosticReports"]);

function existsDir(p) {
  try {
    return fs.existsSync(p) && fs.statSync(p).isDirectory();
  } catch {
    return false;
  }
}

function safeReaddir(dir) {
  try {
    return fs.readdirSync(dir, { withFileTypes: true });
  } catch {
    return null;
  }
}

function safeStat(p) {
  try {
    return fs.statSync(p);
  } catch {
    return null;
  }
}

function shouldIgnore(name) {
  if (!name) return true;
  if (NOISE_NAMES.has(name)) return true;
  if (name === "Caches" || name === "Preferences" || name === "Logs") return true;
  return false;
}

function normalizeKey(name) {
  let s = name.replace(/\.app$/i, "").replace(/\.plist$/i, "").trim();

  // bundle id 類型 -> vendor/product/...
  if (/^[a-z0-9-]+\.[a-z0-9-]+\./i.test(s)) {
    const parts = s.split(".");
    const drop = new Set(["com", "net", "org", "io", "app"]);
    const kept = parts.filter((p, idx) => !(idx === 0 && drop.has(p)));
    s = kept.slice(0, 3).join("/");
  }

  return s.toLowerCase();
}

function displayNameFromKey(key) {
  const parts = key.split("/");
  const nice = parts
    .map((p) => p.replace(/[-_]/g, " ").replace(/\b\w/g, (c) => c.toUpperCase()))
    .join(" / ");
  return nice || key;
}

function scanDir(root) {
  const hits = [];

  const walk = (dir, depth) => {
    if (depth > MAX_DEPTH) return;
    const ents = safeReaddir(dir);
    if (!ents) return;

    for (const ent of ents) {
      const full = path.join(dir, ent.name);
      const st = safeStat(full);
      if (!st) continue;

      // 避免 symlink 造成循環或誤刪
      if (st.isSymbolicLink && st.isSymbolicLink()) continue;

      if (!shouldIgnore(ent.name)) {
        const key = normalizeKey(ent.name);
        if (key && key.length >= 2) hits.push({ key, rawName: ent.name, path: full, root });
      }

      if (ent.isDirectory()) walk(full, depth + 1);
    }
  };

  walk(root, 0);
  return hits;
}

function buildGroups() {
  const allHits = [];
  for (const root of scanRoots) {
    if (!existsDir(root)) continue;
    allHits.push(...scanDir(root));
  }

  const map = new Map(); // key -> group
  for (const h of allHits) {
    if (filter && !h.key.includes(filter) && !h.rawName.toLowerCase().includes(filter)) continue;

    if (!map.has(h.key)) {
      map.set(h.key, {
        key: h.key,
        displayName: displayNameFromKey(h.key),
        roots: new Set(),
        paths: new Set(),
        samples: [],
      });
    }
    const g = map.get(h.key);
    g.roots.add(h.root);
    g.paths.add(h.path);
    if (g.samples.length < 6) g.samples.push(h.path);
  }

  const groups = Array.from(map.values())
    .map((g) => ({
      key: g.key,
      name: g.displayName,
      hitCount: g.paths.size,
      roots: Array.from(g.roots),
      samplePaths: g.samples,
      allPaths: Array.from(g.paths),
    }))
    .filter((g) => g.hitCount >= minHits)
    .sort((a, b) => b.hitCount - a.hitCount || a.name.localeCompare(b.name));

  return groups;
}

function ensureTrashDir() {
  try {
    if (!existsDir(TRASH)) fs.mkdirSync(TRASH, { recursive: true });
  } catch {
    // 如果不行也沒關係，後面會報錯
  }
}

function uniqueTrashPath(originalPath) {
  const base = path.basename(originalPath);
  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  let dest = path.join(TRASH, `${base}__deleted__${stamp}`);
  let i = 1;
  while (fs.existsSync(dest)) {
    dest = path.join(TRASH, `${base}__deleted__${stamp}__${i++}`);
  }
  return dest;
}

function rmRecursive(p) {
  // Node 14+ 支援 fs.rmSync；若你環境更舊可改用 rmdirSync + 遞迴
  fs.rmSync(p, { recursive: true, force: true });
}

function moveToTrash(p) {
  ensureTrashDir();
  const dest = uniqueTrashPath(p);
  try {
    fs.renameSync(p, dest);
    return { ok: true, dest };
  } catch (e) {
    // rename 失敗時（跨磁碟/權限），退回用 copy+rm
    // 只在檔案/資料夾可讀寫時才可能成功
    try {
      const st = fs.statSync(p);
      if (st.isDirectory()) {
        copyDir(p, dest);
        rmRecursive(p);
      } else {
        fs.copyFileSync(p, dest);
        rmRecursive(p);
      }
      return { ok: true, dest, fallback: "copy+rm" };
    } catch (e2) {
      return { ok: false, error: String(e2?.message || e2) };
    }
  }
}

function copyDir(src, dest) {
  fs.mkdirSync(dest, { recursive: true });
  const ents = fs.readdirSync(src, { withFileTypes: true });
  for (const ent of ents) {
    const s = path.join(src, ent.name);
    const d = path.join(dest, ent.name);
    if (ent.isDirectory()) copyDir(s, d);
    else if (ent.isSymbolicLink()) {
      // 不複製 symlink，避免不預期行為
      continue;
    } else {
      fs.copyFileSync(s, d);
    }
  }
}

function matchGroups(groups, q) {
  // 以 key/name 進行包含匹配（實務上比較好用）
  return groups.filter((g) => g.key.includes(q) || g.name.toLowerCase().includes(q));
}

function printGroups(groups) {
  console.log(`Found ${groups.length} candidate app residue groups`);
  console.log(`Scanned roots: ${scanRoots.filter(existsDir).length}/${scanRoots.length} (use --system to include /Library)`);
  if (filter) console.log(`Filter: ${filter}`);
  console.log("");

  groups.forEach((it, idx) => {
    console.log(`${String(idx + 1).padStart(3, " ")}. ${it.name}  (hits: ${it.hitCount})`);
    console.log(`     key: ${it.key}`);
    console.log(`     roots: ${it.roots.join(", ")}`);
    console.log(`     sample paths:`);
    it.samplePaths.forEach((p) => console.log(`       - ${p}`));
    if (it.allPaths.length > it.samplePaths.length) {
      console.log(`       ... (+${it.allPaths.length - it.samplePaths.length} more)`);
    }
    console.log("");
  });
}

function runDelete(groups, q) {
  const targets = matchGroups(groups, q);

  if (targets.length === 0) {
    console.error(`No matching groups for --delete=${q}`);
    console.error(`Tip: run without --delete first, then copy a keyword from "key" or "name".`);
    process.exitCode = 2;
    return;
  }

  // 收斂要刪除的 path（去重）
  const paths = new Set();
  targets.forEach((g) => g.allPaths.forEach((p) => paths.add(p)));

  const pathList = Array.from(paths).sort();

  console.log(`Matched groups: ${targets.length}`);
  targets.forEach((g) => console.log(` - ${g.name} (key: ${g.key}, hits: ${g.hitCount})`));
  console.log("");
  console.log(`Total unique paths to remove: ${pathList.length}`);
  console.log(`Mode: ${force ? (permanentRm ? "PERMANENT DELETE (--rm)" : "MOVE TO TRASH") : "DRY-RUN (add --force to execute)"}`);
  console.log("");

  // Dry-run 先列出
  pathList.forEach((p) => console.log(` - ${p}`));

  if (!force) {
    console.log("\nDry-run only. Re-run with --force to execute.");
    if (!permanentRm) console.log("Default action is moving items to ~/.Trash (safer). Add --rm for permanent deletion.");
    return;
  }

  console.log("\nExecuting...\n");

  const results = [];
  for (const p of pathList) {
    // 額外安全：避免把家目錄或 Library 根砍掉
    const normalized = path.normalize(p);
    const dangerous = new Set([HOME, path.join(HOME, "Library"), "/Library", "/Applications"]);
    if (dangerous.has(normalized)) {
      results.push({ path: p, ok: false, error: "Refused: dangerous root path" });
      continue;
    }

    try {
      if (!fs.existsSync(p)) {
        results.push({ path: p, ok: true, skipped: "not found" });
        continue;
      }

      if (permanentRm) {
        rmRecursive(p);
        results.push({ path: p, ok: true, action: "rm" });
      } else {
        const r = moveToTrash(p);
        if (r.ok) results.push({ path: p, ok: true, action: "trash", dest: r.dest, fallback: r.fallback });
        else results.push({ path: p, ok: false, error: r.error });
      }
    } catch (e) {
      results.push({ path: p, ok: false, error: String(e?.message || e) });
    }
  }

  const ok = results.filter((r) => r.ok).length;
  const fail = results.length - ok;

  console.log(`Done. success=${ok}, failed=${fail}`);
  if (fail) {
    console.log("\nFailures:");
    results
      .filter((r) => !r.ok)
      .slice(0, 50)
      .forEach((r) => console.log(` - ${r.path}: ${r.error}`));
    if (fail > 50) console.log(` ... (+${fail - 50} more)`);
  }

  if (!permanentRm) {
    console.log(`\nMoved items are in: ${TRASH}`);
  }
}

function main() {
  const groups = buildGroups();

  if (asJson) {
    process.stdout.write(JSON.stringify({ generatedAt: new Date().toISOString(), items: groups }, null, 2));
    return;
  }

  if (deleteQuery) {
    runDelete(groups, deleteQuery);
    return;
  }

  // 預設：只列出
  printGroups(groups);

  console.log("Tips:");
  console.log("- narrow down: --filter=<keyword> (e.g., --filter=chrome)");
  console.log("- reduce noise: --minHits=2");
  console.log("- include system paths: --system");
  console.log("- delete residues: --delete=<AppName> (dry-run), add --force to execute");
  console.log("- permanent delete: add --rm (DANGEROUS)");
}

main();